package aps

import org.jetbrains.kotlin.cli.jvm.K2JVMCompiler
import java.time.LocalDateTime
import javax.script.ScriptEngine
import javax.script.ScriptEngineManager
import kotlin.properties.Delegates.notNull
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.psi.KtNamedFunction
import org.jetbrains.kotlin.psi.KtVisitor
import java.io.File
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeFormatterBuilder

object Spew {

    @JvmStatic fun main(args: Array<String>) {
        // generateInPlaceShit()
        generateSeparateShit()
        clog("We good")
    }



    class generateSeparateShit {
        val backOutFile = File(const.file.APS_HOME + "/back/src/aps/back/generated-back.kt")
        val backCode = StringBuilder()
        val shitBack = Shitter(backCode, indent = 0)

        val frontOutFile = File(const.file.APS_HOME + "/front/src/aps/front/generated-front.kt")
        val frontCode = StringBuilder()
        val shitFront = Shitter(frontCode, indent = 0)

        val sharedOutFile = File(const.file.APS_HOME + "/shared/src/aps/generated-shared.kt")
        val sharedCode = StringBuilder()
        val shitShared = Shitter(sharedCode, indent = 0)

        init {
            shitHeaderComment(shitBack, "aps.back")
            shitHeaderComment(shitFront, "aps.front")
            shitHeaderComment(shitShared, "aps")

            val backSrcFiles = listOf("rp-test-2.kt")
            val backPaths = backSrcFiles.map {const.file.APS_HOME + "/back/src/aps/back/$it"}

            val e = try {
                clog("Working like a dog, analyzing your crappy sources...")
                FuckedCLICompiler.doMain(FuckedK2JVMCompiler(), backPaths.toTypedArray())
                wtf("85b5227a-6b8d-4be9-b185-5e8bf6c2491f")
            } catch (e: EnoughFuckedCompiling) {
                e
            }

            val files = e.environment.getSourceFiles()
            for (file in files) {
                file.accept(object:KtVisitor<Unit, Unit>() {
                    override fun visitKtFile(file: KtFile, data: Unit?) {
                        for (decl in file.declarations) {
                            decl.accept(this)
                        }
                    }
                    override fun visitNamedFunction(function: KtNamedFunction, data: Unit?) {
                        // clog("Function:", function.name)
                        for (annotationEntry in function.annotationEntries) {
                            val chars = annotationEntry.node.chars
                            // clog("Annotation:", chars)
                            if (chars == "@Remote")
                                handleRemoteFunction(function)
                        }
                    }
                })
            }

            backupAndWrite(backOutFile, backCode.toString())
            backupAndWrite(frontOutFile, frontCode.toString())
            backupAndWrite(sharedOutFile, sharedCode.toString())
        }

        fun shitHeaderComment(shit: Shitter, packageName: String) {
            shit("""
                /*
                 * APS
                 *
                 * (C) Copyright 2015-2017 Vladimir Grechka
                 *
                 * YOU DON'T MESS AROUND WITH THIS SHIT, IT WAS GENERATED BY A TOOL SMARTER THAN YOU
                 */

                package $packageName

                import aps.*
            """)
            shit("")
        }


        fun handleRemoteFunction(function: KtNamedFunction) {
            val fname = function.name ?: wtf("90c32afc-d7ae-4179-9f2e-77ef6d6c1bb9")
            when {
                fname.startsWith("miranda") -> {
                    clog("Generating Miranda function stub/skeleton for $fname")
                    val sharedParamsClassName = fname.capitalize()
                    val sharedResponseClassName = "GenericResponse"

                    val paramsText = function.valueParameterList?.node?.chars?.toString() ?: wtf("d1e169a7-6502-4fae-bdd6-30ed3d32ea17")
                    val sharedFuckers = paramsText.replace("(", "(val ").replace(",", ", val ")
                    shitShared("""
                        @Generated @Ser class $sharedParamsClassName$sharedFuckers
                    """)

                    val frontFuckers1 = function.valueParameters
                        .map {it.name + ":" + (it.typeReference?.node?.chars ?: wtf("b5c1e203-e1e0-476a-9f52-5f360fe79406"))}
                        .joinToString(", ")
                    val frontFuckers2 = function.valueParameters
                        .map {"${it.name} = ${it.name}"}
                        .joinToString(", ")
                    shitFront("""
                        @Generated suspend fun $fname($frontFuckers1): $sharedResponseClassName = _askMiranda($sharedParamsClassName($frontFuckers2))
                    """)

                    val backFuckers = function.valueParameters
                        .map {"${it.name} = this.${it.name}"}
                        .joinToString(", ")
                    shitBack("""
                        @Generated fun $sharedParamsClassName.serve() {
                            $fname($backFuckers)
                        }
                    """)
                }
                else -> wtf("711d4e81-a807-47df-9101-57e4cae5f500")
            }
        }
    }



    sealed class Token(val text: String) {
        class LittleMotherfucker(text: String) : Token(text)
        class ScriptStart(text: String) : Token(text)
        class ScriptEnd(text: String) : Token(text)
        class GeneratedShitEnd(text: String) : Token(text)
        class EOF(text: String) : Token(text)
    }

    var scriptContext by notNull<SpewScriptContext>()

    class SpewScriptContext(val output: StringBuilder, val indent: Int) {
        @Suppress("Unused")
        fun spewTestFiddlers(type: String) {
            clog("Spewing test fiddlers for $type")
            val out = Shitter(output, indent)
            out("""
                // pizda 2
                suspend fun setValue(field: TestRef<CheckboxFieldSpec>, value: Boolean, subscript: Any? = null) {
                    setValue(FieldSpecToCtrlKey[field.it], value, subscript)
                }

                suspend fun setValue(key: TestRef<CheckboxKey>, value: Boolean, subscript: Any? = null) {
                    setValue(key.it, value, subscript)
                }

                private suspend fun setValue(key: CheckboxKey, value: Boolean, subscript: Any?) {
                    val target = Checkbox.instance(if (subscript == null) key
                                                   else SubscriptCheckboxKey(key, subscript))
                    if (target is Control2) {
                        target.hand()
                    }
                    target.testSetValue(value)
                }
            """)
        }
    }

    fun generateInPlaceShit() {
        val frontFiles = listOf("Checkbox.kt")
        val allPaths = frontFiles.map {const.file.APS_HOME + "/front/src/aps/front/$it"}
        for (path in allPaths) {
            object {
                val file = File(path)
                val fileText = file.readText()
                var pos = 0
                val output = StringBuilder()

                init {
                    parseFile()
                    val newCode = output.toString()
                    File("${const.file.APS_TEMP}/fuck.kt").writeText(newCode)
                    backupAndWrite(file, newCode)
                }

                fun parseFile() {
                    fucking@ while (true) {
                        when (readToken()) {
                            is Token.LittleMotherfucker -> parsePlain()
                            is Token.ScriptStart -> parseScript()
                            is Token.EOF -> break@fucking
                            else -> {
                                clog("Shit at position: [${fileText.substring(pos, pos + 10)}]")
                                wtf("ca8c26bb-2d28-4e1c-94fa-342a2a4611aa")
                            }
                        }
                    }
                }

                fun readToken(): Token {
                    if (pos > fileText.lastIndex) return Token.EOF("")
                    val restText = fileText.substring(pos)
                    Regex("^[ \\t]*//// -----\\r?\\n").find(restText)?.let {return Token.ScriptEnd(it.value)}
                    Regex("^[ \\t]*//// =====\\r?\\n").find(restText)?.let {return Token.GeneratedShitEnd(it.value)}
                    "////".let {if (restText.startsWith(it)) return Token.ScriptStart(it)}
                    return Token.LittleMotherfucker(restText.substring(0, 1))
                }

                inline fun <reified T : Token> slurp(): T {
                    val token = readToken() as? T ?: bitch("Expecting fucking ${T::class.simpleName}")
                    pos += token.text.length
                    return token
                }

                fun parsePlain() {
                    output += slurp<Token.LittleMotherfucker>().text
                    while (readToken() is Token.LittleMotherfucker) {
                        output += slurp<Token.LittleMotherfucker>().text
                    }
                }

                fun parseScript() {
                    output += slurp<Token.ScriptStart>().text

                    val scriptBuf = StringBuilder()
                    while (readToken() is Token.LittleMotherfucker) {
                        val text = slurp<Token.LittleMotherfucker>().text
                        output += text
                        scriptBuf += text
                    }
                    val endText = slurp<Token.ScriptEnd>().text
                    output += endText

                    val indent = endText.length - endText.trimStart().length
                    val script = scriptBuf.toString()

                    clog("Executing script: [$script]")
                    val engine = getKTSEngine()
                    scriptContext = SpewScriptContext(output, indent)
                    engine.eval("""
                            val ctx = ${Spew::class.qualifiedName}.scriptContext
                            $script
                        """)

                    while (readToken() is Token.LittleMotherfucker) { // Skipping previously generated shit
                        slurp<Token.LittleMotherfucker>().text
                    }
                    output += slurp<Token.GeneratedShitEnd>().text
                }
            }
        }
    }

    fun getKTSEngine(): ScriptEngine {
        K2JVMCompiler.main(arrayOf("-version")) // XXX Without this it shits with "Failed to initialize native filesystem for Windows"
        val engine = ScriptEngineManager().getEngineByExtension("kts")!!
        clog("Engine: $engine")

        engine.eval("// Print all your dumb warnings, which we don't give a fuck about")
        clog(); clog(); clog(); clog()
        return engine
    }

    private fun backupAndWrite(file: File, newCode: String) {
        backup(file)
        file.writeText(newCode)
    }


    fun backup(file: File) {
        check(file.path.startsWith(const.file.APS_HOME)) {"9911cfc6-6435-4a54-aa74-ad492162181a"}

        val stamp = LocalDateTime.now().format(PG_LOCAL_DATE_TIME).replace(Regex("[ :\\.]"), "-")
        val outPath = (
            const.file.APS_TEMP + "/spew-bak/" +
                file.path
                    .substring(const.file.APS_HOME.length)
                    .replace("\\", "/")
                    .replace(Regex("^/"), "")
                    .replace("/", "--")
                + "----$stamp"
            )

        clog("Backing up: $outPath")
        File(outPath).writeText(file.readText())
    }

    class Shitter(val output: StringBuilder, val indent: Int) {
        operator fun invoke(src: String) {
            var s = dedent(src)
            s = reindent(indent, s)
            if (!s.endsWith("\n")) s += "\n"
            output += s
        }
    }
}


// TODO:vgrechka Extract below from `back` into something stable that cannot be broken by code generation


object const {
    object file {
        val APS_HOME = "e:\\work\\aps"
        val APS_TEMP = "c:/tmp/aps-tmp"
    }
}

fun clog(vararg xs: Any?): Unit = println(xs.joinToString(" "))

fun wtf(msg: String = "...WTF didn't you describe this WTF?"): Nothing = throw Exception("WTF: $msg")

fun dedent(it: String): String {
    var lines = it.split(Regex("\\r?\\n"))
    if (lines.size > 0 && lines[0].isBlank()) {
        lines = lines.drop(1)
    }
    if (lines.size > 0 && lines.last().isBlank()) {
        lines = lines.dropLast(1)
    }

    var minIndent = 9999 // TODO:vgrechka Platform-specific max integer (for JS: Number.MAX_SAFE_INTEGER)
    for (line in lines) {
        if (!line.isBlank()) {
            val lineIndent = line.length - line.trimStart().length
            if (lineIndent < minIndent) {
                minIndent = lineIndent
            }
        }
    }

    return lines.map {line ->
        if (line.trim().isBlank()) ""
        else line.substring(minIndent)
    }.joinToString("\n")
}

fun reindent(newIndent: Int, it: String): String {
    return dedent(it).split("\n").joinToString("\n") {" ".repeat(newIndent) + it}
}

operator fun StringBuilder.plusAssign(x: Any?) {
    this.append(x)
}

val PG_LOCAL_DATE_TIME = DateTimeFormatterBuilder()
    .parseCaseInsensitive()
    .append(DateTimeFormatter.ISO_LOCAL_DATE)
    .appendLiteral(' ')
    .append(DateTimeFormatter.ISO_LOCAL_TIME)
    .toFormatter()!!

fun bitch(msg: String = "Just bitching..."): Nothing = throw Exception(msg)

fun stringBuild(block: (StringBuilder) -> Unit) =
    StringBuilder().also(block).toString()

