Assertion ID. Used
    - by Update Expectation button
    - by Go To Expectation link
    - by human to locate assertion code manually
    - @consider Pieces of implementation code can be annotated with IDs of assertions that exercise them

Assertion code should be both human- and machine-writable.
Assertion code should be both human- and machine-readable.
Can it be for human and machine at the same time?
Probably not. It should be clearly visible _at runtime_ whether assertion expectation is designed
for "Update Expectation" button.
Even if assertion is machine-writeable, it should not make test script completely unreadable.

Assertion can have or have not UUID assigned to it, AID.
Actually, it seems reasonable that most assertions should have AID.
In addition to "Update Expectation" button there are other benefits, such as referencing in bug tracking system, in implementation code, etc.
Implement :uuid editor command to quickly insert new UUIDs into code.

Mail assertions should be all machine-oriented. No need to support two approaches --> less work, easier code.
It's too cumbersome to manage them manually anyway.
Maybe implement editor feature to show actual expected mail when hovering over corresponding AID.

...More and more often I'm starting to think that _strict_ "test-first" approach is bullshit in most real-world use cases :)
The only real good thing _associated_ with TDD is usage-first thinking. But I have such thinking without having to resort to TDD practices.
In fact it's better to first write REAL usage code rather than TEST usage code. Because test usage code will be contrived.
Afterwards achieved behavior can be hardened in test code. But only after it's actually clear what it should be like.
And in most real cases in the very beginning it is not clear at all what it should be like.
TDD makes everything more difficult. Everything, for everyone. And it never actually works as advertised anyway.
I'm not even thinking now about "mock everything" approach (aka "unit test should only test tiny unit without any collaborations").
This one is completely insane. And there was time when I thought it was cool... It's crazy... :)
Not to mention that whoule idea of tiny collaborating units more and more starting to smell like shit to me... :)
Not to mention TDD prevents exploratory programming and creativity.
Damn. Intuition says it's just not right. And because earlier intuition said to me it was right, and because now I'm, hopefully,
better programmer than I was that time, conclusion is to fuck TDD :)
Neither of two extremes ("no tests" vs. "TDD") are good.
Better practical workflow which I'm gonna implement in this project:
    1. Explore and decide what to implement by actually implementing it
    2. Write test scenario with empty machine-replaceable paceholders in assertions
    3. Test will fail because empty expectations don't match actual things (that are already implemented _to some degree_)
    4. When test scenario fails, Assertion Error Pane appears at the bottom of corresponding screen. It contains:
           - Convenient red-green diff of expected and actual thing. Practice shows that in most cases it's
             sufficient to just util.inspect() actual and expected objects, then do usual text diffing algorithm and show
             red-green-stripes comparison report
           - Source-mapped stack trace with links, clicking on which actually opens Eclipse on corresponding lines
           - Update Expectation button, clicking on which modifies test script to match what's now in reality
    5. Play with implementation and tweak it so that Assertion Error Pane shows what seems reasonable in Actual section
    6. Click Update Expectation, and current actual behavior will be hardened in test code
    7. Almost for sure, actual behavior will change in future. When it happens (and we get Assertion Error Pane),
       we again think if what's in Actual section is reasonable, again possibly tweak _both_ implementation and our thinking,
       and finally click Update Expectation button to harden new vision.
       
    